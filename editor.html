<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Metadaten Editor</title>
  <link rel="stylesheet" href="/editor.css" />
  <script src="editor-api-key.js"></script>
</head>
<body class="p-10">
<div class="card bg-base-100 shadow-xl max-w-4xl mx-auto">
  <div class="card-body">
    <h1 class="card-title text-3xl">Metadaten Editor</h1>
    <p>Wähle einen Ordner aus, um alle darin enthaltenen Bilder zu überprüfen und die fehlende Titel zu ergänzen.</p>
    <p id="progressIndicator" class="font-semibold text-info"></p>
    <div class="card-actions">
      <button id="selectFolderBtn" class="btn btn-primary">Ordner auswählen</button>
    </div>

    <div id="editor" class="hidden mt-5">
      <p class="file-info italic text-sm mb-2">
        Bearbeite Datei: <b id="fileName"></b>
      </p>
      <form id="titleForm">
        <img
          id="referenceImage"
          alt="Referenzbild"
          class="max-w-full h-auto rounded my-4 mx-auto object-contain"
          style="display: none; max-height: 400px"
        >

        <div id="autoDescribeProgress" class="flex items-center gap-2 my-2">
          <span class="loading loading-spinner text-primary"></span>
          <span>Bild wird automatisch beschrieben…</span>
        </div>

        <label for="titleInput" class="block font-medium">Titel:</label>
        <textarea rows="3"
                  id="titleInput"
                  required
                  class="textarea textarea-bordered w-full text-base mb-4"
        ></textarea>

        <div class="card-actions">
          <button type="submit" class="btn btn-primary">Speichern und nächste Datei laden</button>
          <button type="button" id="redoDescriptionBtn" class="btn btn-secondary" disabled>KI-Bildbeschreibung wiederholen</button>
        </div>
      </form>
    </div>

    <div id="successMessage" class="hidden">
      <div role="alert" class="alert alert-success">
        <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
        <div>
          <h2 class="text-2xl font-bold">Alle Dateien wurden erfolgreich verarbeitet!</h2>
          <p>Es gibt keine weiteren YAML-Dateien ohne Titel in diesem Ordner.</p>
        </div>
      </div>
    </div>
  </div>
</div>

<script type="module">
  // The existing JavaScript code remains unchanged
  import { GoogleGenAI } from "https://cdn.jsdelivr.net/npm/@google/genai@1/+esm";
  import jsyaml from "https://cdn.jsdelivr.net/npm/js-yaml@4/+esm";

  const ai = new GoogleGenAI({ apiKey: GEMINI_API_KEY, model: "gemini-2.5-flash" });

  const selectFolderBtn = document.getElementById("selectFolderBtn");
  const editorDiv = document.getElementById("editor");
  const successMessageDiv = document.getElementById("successMessage");
  const fileNameEl = document.getElementById("fileName");
  const titleForm = document.getElementById("titleForm");
  const titleInput = document.getElementById("titleInput");
  const referenceImage = document.getElementById("referenceImage");
  const autoDescribeProgress = document.getElementById("autoDescribeProgress");
  const progressIndicator = document.getElementById("progressIndicator");

  let directoryHandle = null;
  let filesToProcess = [];

  async function readYaml(yamlHandle) {
    const yamlFile = await yamlHandle.getFile();
    return jsyaml.load(await yamlFile.text());
  }


  async function collectMarkdownContent(folderHandle) {
    if (folderHandle === null) return "";
    let content = "";
    for await (const entry of folderHandle.values()) {
      if (entry.kind === "file" && (entry.name.endsWith(".md") || entry.name.endsWith(".mdx"))) {
        try {
          const fileHandle = await folderHandle.getFileHandle(entry.name, { "mode": "read" });
          const file = await fileHandle.getFile();
          content += await file.text() + "\n";
        } catch (e) {
          // ignore errors reading individual files
        }
      }
    }
    return content.trim();
  }

  const EXTENSIONS = [".jpg", ".jpeg", ".png", ".gif", ".webp", ".svg"];

  // Rekursive Funktion, um YAML-Dateien inkl. Subordner zu sammeln
  async function collectYamlFilesInFolder(folderHandle, parentFolderHandle, files = [], relativePath = "") {
    for await (const entry of folderHandle.values()) {
      for (const ext of EXTENSIONS) {
        if (entry.kind === "file" && entry.name.endsWith(ext)) {
          const yamlFileName = entry.name.replace(new RegExp(`${ext.replace(".", "\.")}`), ".yaml");
          let yamlHandle = null;
          try {
            yamlHandle = await folderHandle.getFileHandle(yamlFileName, { "mode": "read" });
            const data = await readYaml(yamlHandle);
            if (data && typeof data.title === "string" && data.title.trim().length > 0) {
              continue;
            }
          } catch (e) {
            // ignore
          }
          const item = {
            handle: yamlHandle,
            parentHandle: folderHandle,
            relativePath: relativePath + yamlFileName,
            associatedJpgName: entry.name,
            context: await collectMarkdownContent(parentFolderHandle) + await collectMarkdownContent(folderHandle)
          };
          files.push(item);

        }
      }
      if (entry.kind === "directory") {
        await collectYamlFilesInFolder(entry, folderHandle, files, relativePath + entry.name + "/");
      }
    }
    return files;
  }


  function updateProgress() {
    // Gesamte Anzahl ist die aktuelle + die Anzahl der verbleibenden im Stack (inkl. aktuellem)
    const remaining = filesToProcess.length + (editorDiv.style.display === "block" ? 1 : 0);
    if (remaining > 0) {
      progressIndicator.textContent = `Noch ${remaining} Bild${remaining !== 1 ? "er" : ""} zu bearbeiten`;
    } else {
      progressIndicator.textContent = "Letztes Bild zu bearbeiten";
    }
  }

  selectFolderBtn.addEventListener("click", async () => {
    try {
      directoryHandle = await window.showDirectoryPicker();
      filesToProcess = await collectYamlFilesInFolder(directoryHandle);
      selectFolderBtn.style.display = "none";
      updateProgress();
      await processNextFile();
    } catch (err) {
      console.error("Fehler beim Auswählen des Ordners:", err);
      alert("Der Ordner konnte nicht ausgewählt werden. Bitte versuchen Sie es erneut.");
    }
  });


  const redoDescriptionBtn = document.getElementById("redoDescriptionBtn");
  redoDescriptionBtn.addEventListener("click", async () => {
    referenceImage.onload();
  });

  function displaySuccessMessage() {
    editorDiv.style.display = "none";
    progressIndicator.style.display = "none";
    successMessageDiv.style.display = "block";
    updateProgress();
  }

  function assertYamlFileHandle(fileHandle) {
    const valid = fileHandle.name.toLowerCase().endsWith(".yaml");
    if (!valid) {
      throw new Error(`Invalid file type: ${fileHandle.name}. Only .yaml files are allowed`);
    }
  }

  async function processNextFile() {
    if (filesToProcess.length === 0) {
      displaySuccessMessage();
      return;
    }
    const fileObj = filesToProcess.shift();
    const context = fileObj.context;
    const needsCreation = fileObj.handle === null;

    updateProgress();

    try {
      const data = needsCreation ? {} : readYaml(fileObj.handle);
      if (data && (data.title === null || data.title === "" || typeof data.title === "undefined")) {
        fileNameEl.textContent = fileObj.relativePath;
        referenceImage.alt = "Pfad zum Bild: " + fileNameEl.textContent + (context !== null ? ". Inhalt des Artikels als weiterer Hinweis: "
          + context : "");
        titleInput.value = "";

        // Bild anzeigen, falls vorhanden
        let imageName = fileObj.associatedJpgName;

        try {
          const imageHandle = await fileObj.parentHandle.getFileHandle(imageName, { "mode": "read" });
          const imageFile = await imageHandle.getFile();
          referenceImage.src = URL.createObjectURL(imageFile);
          referenceImage.style.display = "block";
        } catch (e) {
          referenceImage.style.display = "none";
          console.warn(`Bild ${imageName} nicht gefunden.`);
        }

        editorDiv.style.display = "block";

        titleForm.onsubmit = async (event) => {
          event.preventDefault();
          data.title = titleInput.value;
          const newYamlContent = jsyaml.dump(data);
          let targetFileHandle = fileObj.handle;

          if (needsCreation) {
            targetFileHandle = await fileObj.parentHandle.getFileHandle(
              fileObj.relativePath.split("/").pop(),
              { create: true }
            );
          }


          assertYamlFileHandle(targetFileHandle);

          const writable = await targetFileHandle.createWritable();
          await writable.write(newYamlContent);
          await writable.close();
          await processNextFile();
        };
      } else {
        await processNextFile();
      }
    } catch (e) {
      console.error(`Fehler beim Parsen der YAML-Datei ${fileObj.relativePath}:`, e);
      alert(`Die Datei ${fileObj.relativePath} konnte nicht gelesen werden. Sie ist möglicherweise fehlerhaft.`);
      await processNextFile();
    }
  }

  async function getCompressedBase64(imgElement, maxSide = 2024, quality = 0.7) {
    const response = await fetch(imgElement.src);
    const blob = await response.blob();
    const img = await new Promise((resolve, reject) => {
      const image = new Image();
      image.onload = () => resolve(image);
      image.onerror = reject;
      image.src = URL.createObjectURL(blob);
    });

    let { width, height } = img;
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

    // Convert to Base64
    const dataUrl = canvas.toDataURL("image/webp", quality);
    return dataUrl.split(",")[1];
  }

  // 2. Describe image using Gemini Vision API
  async function describeImageWithGemini(imgElement) {
    //  return new Promise(resolve => setTimeout(resolve, 100)); // Uncomment this line to not call Gemini
    const base64Content = await getCompressedBase64(imgElement);
    try {
      const content = {
        model: "gemini-2.5-flash",
        contents: [{
          inlineData: {
            mimeType: "image/webp",
            data: base64Content
          }
        },
          {
            text:
              `Aus dem Pfad des Bildes, das beschrieben werden soll kann potentiell ein möglicher Kontext geschlossen werden: ${referenceImage.alt}`
          }, {
            text:
              "Die Black Wings Linz (BWL) sind eine Eishockey Mannschaft aus Linz und spielen in der Linz AG Eisarena. Ihre Heimdressen sind dunkel. Der LASK (ASK) ist ein Fußballverein mit hellen Dressen und spielt in der Raiffeisen Arena in Linz. Nero steht für die Nero Summer Series Upper Austria und ist eine Serie an Vorbereitungsspielen, die in der Raiffeisen Arena stattfindet"
          },
          {
            text:
              "Beschreibe das Bild. Es soll als ALT Tag des Bildes verwendet werden. Gib nur die Beschreibung ohne Formatierung und keinen weiteren Text aus. Denke daran die Beschreibung zu SEO optimieren. Vermeide es unter allen umständen Stichworte zu benutzen. Antworte unbedingt auf Deutsch. Denk daran, dass die Antwort nicht zu lange sein sollte, eher ein Satz und nicht zwei sein soll. Erwähne nicht den Rasen in einem Stadion als Teil der Beschreibung, außer wenn der Rasen ein wichtiger Teil des Bildes ist."
          }
        ]
      };
      const result = await ai.models.generateContent(content);
      const caption = (result?.candidates[0]?.content?.parts[0]?.text).trim();
      return caption.replace(/\.$/, "");
    } catch (err) {
      if (err.status === 429) {
        return { type: "error", message: "Gemini API Rate Limit Exceeded" };
      }
      console.warn("Gemini Image Captioning Error:", err);
      return { type: "error", message: "Beschreibung fehlgeschlagen" };
    }
  }

  // After loading and successfully displaying the image, add this block:
  referenceImage.onload = async () => {
    // Show progress
    autoDescribeProgress.classList.remove("hidden");
    redoDescriptionBtn.disabled = true;
    titleInput.placeholder = "";

    try {
      const caption = await describeImageWithGemini(referenceImage);
      if (caption?.type === "error") {
        titleInput.placeholder = caption.message;
      } else {
        titleInput.value = caption;
      }
    } catch (e) {
      titleInput.placeholder = "Fehler bei automatischer Beschreibung.";
    }
    autoDescribeProgress.classList.add("hidden");
    redoDescriptionBtn.disabled = false;
  };
</script>
</body>
</html>