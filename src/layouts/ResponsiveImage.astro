---
import { Image } from "astro:assets";
import { getImageNameByName, getImageByName } from "../images/Images";
import type { NumericBreakpoints } from "../styles/Breakpoints";
import { computeSizes, DEFAULT_IMAGE_SIZES, mergeBreakpoints } from "../styles/Breakpoints";
import { ResponsiveImageLoading } from "./ResponsiveImageLoading";
import { GALLERY_BREAKPOINTS, GalleryLayout } from "./GalleryLayout";
import { getMetadataFromAbsoluteName } from "./image.utils";

interface Props {
  name: string,
  class?: string,
  height?: string,
  sizes?: string,
  widths?: number[],
  loading?: ResponsiveImageLoading,
  sizeModifiers?: Partial<NumericBreakpoints>
}

const {
  name,
  sizes,
  sizeModifiers,
  widths: widthsOverride,
  loading = ResponsiveImageLoading.LAZY,
  class: classNames
} = Astro.props;

const absoluteName = getImageNameByName(name);
const image = (await getImageByName(absoluteName)).default;
const data = await getMetadataFromAbsoluteName(absoluteName);
const alt = data?.title ?? "";
const darkInvert = data?.darkInvert ?? false;
const computedSizes = computeSizes(mergeBreakpoints(GALLERY_BREAKPOINTS[GalleryLayout.Full], sizeModifiers));
const widths: number[] = (widthsOverride ?? DEFAULT_IMAGE_SIZES).filter(s => s <= image.width);

const maxOptimizedWidth = widths[widths.length - 1];
const maxOptimizedHeight = maxOptimizedWidth * image.height / image.width;
---
<Image
  format="avif"
  class:list={[{ "dark:invert": darkInvert }, classNames]}
  quality="med"
  loading={loading}
  widths={widths}
  sizes={sizes ?? computedSizes}
  data-pswp-width={maxOptimizedWidth}
  data-pswp-height={maxOptimizedHeight}
  src={image}
  alt={alt}
/>
