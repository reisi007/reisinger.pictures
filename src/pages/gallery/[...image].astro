---
import {type AnyEntryMap, getCollection } from "astro:content";
import MinimalPage from "../../layouts/pages/MinimalPage.astro";
import type { InferGetStaticPropsType } from "astro";
import BaseHead from "../../layouts/BaseHead.astro";
import SocialImage from "../../layouts/SocialImage.astro";
import ResponsiveImage from "../../layouts/ResponsiveImage.astro";
import ImageMetadata from "../../layouts/ImageMetadata.astro";
import ImageCategories from "../../layouts/ImageCategories.astro";
import { getEntry } from "astro:content";
import type { Props as ContentCardProps } from "../../layouts/ContentCard.astro";
import { fileContainsStringSync } from "../../utils";

export async function getStaticPaths() {
  return (await getCollection("imageMetadata"))
    .filter(e => !e.id.endsWith("small"))
    .filter(e => {
      const metadata = e.data?.metadata ?? undefined;
      return metadata !== undefined && Object.keys(metadata).length > 0;
    }).map(m => ({ params: { image: m.id }, props: m }));
}

type Props = InferGetStaticPropsType<typeof getStaticPaths>;
const { data } = Astro.props;
const { title, metadata, categories = [] } = data;
const { image } = Astro.params;

async function getEntries<E extends keyof AnyEntryMap>(collection: E) {
  return await getCollection<E>(collection, e => {
    const path = e.filePath;
    if (path === undefined) {
      return false;
    }
    return fileContainsStringSync(path, image) || image.endsWith("-large") && fileContainsStringSync(path, image.substring(0, image.lastIndexOf("-")));
  });
} async function findValidEinblickeEntries(): Promise<ContentCardProps[]> {
  return (await getEntries("einblicke")).map(e => ({
    href: `/einblicke/${e.slug}`,
    imageName: e.data.heroImage ?? image,
    title: e.data.title,
    date: e.data.updated ?? e.data.pubDate
  }));
}

async function findValidSimpleEntry(): Promise<ContentCardProps[]> {
  return (await getEntries("simple")).map(e => ({
    href: e.slug === "/" ? "/" : "/" + e.slug,
    imageName: e.data.heroImage ?? image,
    title: `Erfahre mehr über ${e.data.title}`,
    date: e.data.updated ?? e.data.pubDate
  }));
}

async function findValidTestimonialEntry(): Promise<ContentCardProps | undefined> {
  const regx = /(.+)-large/;
  const result = regx.exec(image);
  if (result === null) {
    return undefined;
  }

  const testimonialId = result[1];
  const testimonial = await getEntry("testimonials", testimonialId);
  if (!testimonial) {
    return undefined;
  }
  return {
    href: "/testimonials/" + testimonialId,
    imageName: image,
    title: `Das sagt ${testimonial.data.name} über ihre Erfahrung`,
    date: testimonial.data.date
  };
}

async function findAreaUsage(): Promise<ContentCardProps[]> {
  return (await getEntries("areas")).map(entry => ({
    href: "/" + entry.slug,
    imageName: entry.data.heroImage ?? image,
    title: `Erfahre mehr über ${entry.data.name}`
  }));
}


const urls: ContentCardProps[] = [
  ...(await findValidEinblickeEntries()),
  await findValidTestimonialEntry(),
  ...(await findAreaUsage()),
  ...(await findValidSimpleEntry())
].filter(e => e !== undefined);

if (!title) {
  return;
}
---
<MinimalPage>
  <BaseHead title={title} slot="head">
    <SocialImage name={image} />
  </BaseHead>
  <h1>{title}</h1>

  <ResponsiveImage name={image} />

  <ImageMetadata {...metadata} />

  {categories && categories.length > 0 &&
    <ImageCategories categories={categories} urls={urls} />}

</MinimalPage>