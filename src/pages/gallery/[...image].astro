---
import { type AnyEntryMap, getCollection } from "astro:content";
import MinimalPage from "../../layouts/pages/MinimalPage.astro";
import type { InferGetStaticPropsType } from "astro";
import BaseHead from "../../layouts/BaseHead.astro";
import SocialImage from "../../layouts/SocialImage.astro";
import ResponsiveImage from "../../layouts/ResponsiveImage.astro";
import ImageMetadata from "../../layouts/ImageMetadata.astro";
import ImageCategories from "../../layouts/ImageCategories.astro";
import { getEntry } from "astro:content";
import type { Props as ContentCardProps } from "../../layouts/ContentCard.astro";
import { asyncFilter, fileContainsString } from "../../utils";
import { type SchemaCreationFunction } from "../../layouts/SchemaOrg";
import { createImagePageSchema } from "../../layouts/SchemaOrg.factory";
import { getImage } from "astro:assets";
import { getImage as getImageByName } from "../../images/Images";
import SchemaOrg from "../../layouts/SchemaOrg.astro";
import { LARGEST_IMAGE_SIZE } from "../../styles/Breakpoints";

type Props = InferGetStaticPropsType<typeof getStaticPaths>;

export async function getStaticPaths() {
  return (await getCollection("imageMetadata"))
    .filter(e => !e.id.endsWith("small"))
    .filter(e => {
      const metadata = e.data?.metadata ?? undefined;
      return metadata !== undefined && Object.keys(metadata).length > 0;
    }).map(m => ({ params: { image: m.id }, props: m }));
}

const { data } = Astro.props;
const { title, metadata, categories = [] } = data;
const { image } = Astro.params;

async function getEntries<E extends keyof AnyEntryMap>(collection: E) {
  return asyncFilter(await getCollection<E>(collection), async e => {
    const path = e.filePath;
    if (path === undefined) {
      return false;
    }
    const containsImage = await fileContainsString(path, image);
    if (containsImage) return true;
    const testimonialId = await computeTestimonialId();
    return testimonialId !== undefined && await fileContainsString(path, testimonialId);
  });
} async function findValidEinblickeEntries(): Promise<ContentCardProps[]> {
  return (await getEntries("einblicke")).map(e => ({
    href: `/einblicke/${e.slug}`,
    imageName: e.data.heroImage ?? image,
    title: e.data.title,
    date: e.data.updated ?? e.data.pubDate
  }));
}

async function findValidSimpleEntry(): Promise<ContentCardProps[]> {
  return (await getEntries("simple")).map(e => ({
    href: e.slug === "/" ? "/" : "/" + e.slug,
    imageName: e.data.heroImage ?? image,
    title: `Erfahre mehr über ${e.data.title}`,
    date: e.data.updated ?? e.data.pubDate
  }));
}

async function computeTestimonialId() {
  const regx = /(.+)-large/;
  const result = regx.exec(image);
  const testimonialId = result?.at(1);
  if (testimonialId)
    return testimonialId;
  const testimonials = await getCollection("testimonials", e => e.data.largeImage === image);
  return testimonials?.at(0)?.id;
}

async function findValidTestimonialEntry(): Promise<ContentCardProps | undefined> {
  const testimonialId = await computeTestimonialId();
  if (testimonialId === undefined) {
    return undefined;
  }
  const testimonial = await getEntry("testimonials", testimonialId);
  if (!testimonial) {
    return undefined;
  }
  return {
    href: "/testimonials/" + testimonialId,
    imageName: image,
    title: `Das sagt ${testimonial.data.name} über ihre Erfahrung`,
    date: testimonial.data.date
  };
}

async function findAreaUsage(): Promise<ContentCardProps[]> {
  return (await getEntries("areas")).map(entry => ({
    href: "/" + entry.slug,
    imageName: entry.data.heroImage ?? image,
    title: `Erfahre mehr über ${entry.data.name}`
  }));
}

const urls: ContentCardProps[] = [
  ...(await findValidEinblickeEntries()),
  await findValidTestimonialEntry(),
  ...(await findAreaUsage()),
  ...(await findValidSimpleEntry())
].filter(e => e !== undefined);

if (!title) {
  return;
}

const schemaOrgImage = await getImage({
  src: getImageByName(image),
  format: "webp",
  width: LARGEST_IMAGE_SIZE,
  fit: "scale-down"
});


const createData: SchemaCreationFunction = (o, p, df, url) => createImagePageSchema({
  pageName: title,
  pageUrl: url,
  imageName: image,
  imageDescription: title,
  contentUrl: schemaOrgImage.src,
  width: schemaOrgImage.attributes.width as number,
  height: schemaOrgImage.attributes.height as number,
  author: p,
  publisher: o,
  datePublished: df(metadata?.captureDate)
});
---
<MinimalPage>
  <BaseHead title={title} slot="head">
    <SocialImage name={image} />
    <SchemaOrg createData={createData} />
  </BaseHead>
  <h1>{title}</h1>

  <ResponsiveImage name={image} />

  <ImageMetadata {...metadata} />

  {categories && categories.length > 0 &&
    <ImageCategories categories={categories} urls={urls} />}

</MinimalPage>